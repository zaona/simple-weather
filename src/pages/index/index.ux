<template>
  <!-- é¡µé¢å®¹å™¨ -->
  <div class="page-container">
    <!-- èƒŒæ™¯å›¾ç‰‡ -->
    <image class="page-bg" src="/common/weather-bgs/{{ backgroundImage }}.png" />

    <!-- åŠ è½½åŠ¨ç”»å®¹å™¨ -->
    <div class="loading-container" if="{{ isLoading }}">
      <div class="loading-bg"></div>
      <image class="loading-icon" src="/common/loading.png" />
    </div>

    <scroll
      class="main-content scroll-container"
      scroll-y="true"
      bounces="true"
      if="{{ !isLoading }}"
    >
      <!-- å¤´éƒ¨ä¿¡æ¯ï¼šåœ°ç‚¹å’Œæ›´æ–°æ—¶é—´ -->
      <div class="page-header">
        <text class="text-location">{{ location }}</text>
        <text class="text-subtitle">{{ updateTime }}</text>
      </div>

      <!-- å½“å‰å¤©æ°”æ¦‚è§ˆ -->
      <div class="content-hero card-margin">
        <image class="icon-weather-main" src="/common/weather-icons/{{ iconCode }}.png" />
        <text class="text-weather">{{ textDay }}</text>
        <text class="text-temp-range">{{ tempMinMax }}</text>
      </div>

      <!-- é€å°æ—¶å¤©æ°”é¢„æŠ¥ -->
      <div class="card card-single" if="{{ showHourlyForecastCard }}">
        <scroll
          class="mt-negative-sm"
          style="margin: -4px"
          scroll-x="true"
          bounces="true"
        >
          <div class="item-hourly" for="{{ item in figureHourly }}">
            <text class="text-hourly">
              {{ item.name }}
            </text>
            <image class="icon-weather-small" src="/common/weather-icons/{{ item.iconCode }}.png" />
            <text class="text-hourly-temp" style="">
              {{ item.temp }}
            </text>
          </div>
        </scroll>
      </div>

      <!-- å¤©æ°”æŒ‡æ ‡é¢æ¿ -->
      <div class="card card-double">
        <div class="item-data" for="{{ item in figure }}">
          <text class="text-data-value">{{ item.value }}{{ item.unit }}</text>
          <text class="text-data-label">{{ item.name }}</text>
        </div>
      </div>

      <!-- æœªæ¥å‡ å¤©å¤©æ°”é¢„æŠ¥ -->
      <div class="card card-single">
        <div class="flex-col mt-negative-sm">
          <div class="item-forecast" for="{{ item in dayWeather }}" @click="DetailInfo(item)">
            <text class="text-daily">{{ item.name }}</text>
            <div class="justify-between">
              <text class="text-daily-temp">{{ item.tempMinMax }}</text>
              <image
                class="icon-weather-small"
                src="/common/weather-icons/{{ item.iconCode }}.png"
              />
            </div>
          </div>
        </div>
      </div>

      <div class="content-hero mt-lg">
        <div class="btn-primary" onclick="About()">
          <text class="text-button">å…³äº</text>
        </div>
      </div>
    </scroll>
  </div>
</template>

<script>
// å¯¼å…¥ç³»ç»Ÿæ¨¡å—
import router from "@system.router"
import {showToast} from "@system.prompt"

// å¯¼å…¥æœåŠ¡å±‚
import DataService from "../../services/data-service.js"
import ConnectionService from "../../services/connection-service.js"
import DebugService from "../../services/debug-service.js"
import SettingsService from "../../services/settings-service.js"
import HourlyDataService from "../../services/hourly-data-service.js"
import DeviceService from "../../services/device-service.js"
import WeatherApiService, {WEATHER_API_ERRORS} from "../../services/weather-api-service.js"
import {MESSAGES, TOAST_DURATION, AUTO_UPDATE, ADVANCED_FEATURE_PRODUCTS} from "../../services/config.js"

// å¯¼å…¥å·¥å…·ç±»
import {DateUtils, WeatherDataUtils} from "../../common/weather-utils.js"

export default {
  // é¡µé¢ç§æœ‰æ•°æ®
  private: {
    isLoading: true, // åŠ è½½çŠ¶æ€
    isFirstLoad: true, // æ˜¯å¦æ˜¯é¦–æ¬¡åŠ è½½
    autoUpdateEnabled: false, // è‡ªåŠ¨æ›´æ–°æ˜¯å¦å¼€å¯
    hourlyForecastEnabled: false, // é€å°æ—¶å¤©æ°”æ˜¯å¦å¼€å¯
    showHourlyForecastCard: false, // æ˜¯å¦æ˜¾ç¤ºé€å°æ—¶å¡ç‰‡
    supportsAdvancedFeatures: false, // è®¾å¤‡æ˜¯å¦æ”¯æŒé«˜çº§åŠŸèƒ½
    hasHourlyData: false, // æ˜¯å¦æœ‰å¯ç”¨çš„é€å°æ—¶æ•°æ®
    autoUpdateInProgress: false, // è‡ªåŠ¨æ›´æ–°ä¸­æ ‡è®°
    location: "__", // åœ°ç‚¹
    updateTime: "__", // æ›´æ–°æ—¶é—´
    iconCode: "__", // å¤©æ°”å›¾æ ‡ä»£ç 
    textDay: "__", // ç™½å¤©å¤©æ°”æè¿°
    tempMinMax: "__Â°/__Â°", // æœ€é«˜/æœ€ä½æ¸©åº¦
    backgroundImage: "", // èƒŒæ™¯å›¾ç‰‡

    // å¤©æ°”æŒ‡æ ‡æ•°æ®
    figure: [
      {name: "ç´«å¤–çº¿æŒ‡æ•°", value: "__", uniqueId: 1},
      {name: "ç›¸å¯¹æ¹¿åº¦", value: "__", uniqueId: 2},
      {name: "__", value: "__", uniqueId: 3},
      {name: "æ°”å‹", value: "__", uniqueId: 4}
    ],

    // é€å°æ—¶å¤©æ°”é¢„æŠ¥æ•°æ®
    figureHourly: [],

    // æœªæ¥å‡ å¤©å¤©æ°”é¢„æŠ¥æ•°æ®
    dayWeather: [{name: "__", tempMinMax: "__", iconCode: "__", uniqueId: 1}]
  },

  /**
   * è·³è½¬åˆ°è¯¦æƒ…é¡µ
   * @param {Object} selectedItem - é€‰ä¸­çš„å¤©æ°”é¡¹
   */
  DetailInfo(selectedItem) {
    if (selectedItem && selectedItem.fxDate) {
      router.push({
        uri: "/pages/detail",
        params: {
          selectedDate: selectedItem.fxDate
        }
      })
    } else {
      showToast({
        message: MESSAGES.NAVIGATION_ERROR,
        duration: TOAST_DURATION.NORMAL
      })
    }
  },

  /**
   * è·³è½¬åˆ°å…³äºé¡µ
   */
  About() {
    router.push({
      uri: "/pages/about"
    })
  },

  /**
   * æ›´æ–°å¤©æ°”æ•°æ®
   * @param {Object|boolean} options - é…ç½®é¡¹æˆ–æ˜¯å¦è‡ªåŠ¨è§¦å‘
   * @returns {Promise<boolean>}
   */
  async UpdateWeather(options = {}) {
    let config = {auto: false, silent: false, showLoading: null}

    if (typeof options === "boolean") {
      config.auto = options
    } else {
      config = {...config, ...options}
    }

    const shouldShowLoading = config.showLoading !== null ? config.showLoading : !config.auto

    if (this.isLoading && shouldShowLoading) {
      return false
    }

    if (shouldShowLoading) {
      this.isLoading = true
    }

    try {
      const weatherData = await WeatherApiService.fetchWeatherWithLocation()
      const saved = await DataService.saveWeatherData(JSON.stringify(weatherData))

      if (!saved) {
        return false
      }

      const result = await this.loadWeatherData(true)

      if (!result || !result.success) {
        if (!config.silent) {
          showToast({
            message: MESSAGES.DATA_PARSE_ERROR,
            duration: TOAST_DURATION.NORMAL
          })
        }
        return false
      }

      if (!config.silent) {
        showToast({
          message: MESSAGES.DATA_UPDATED,
          duration: TOAST_DURATION.SHORT
        })
      }

      return true
    } catch (error) {
      console.error("è·å–å¤©æ°”å¤±è´¥:", error)
      const toastMessage =
        error?.code === WEATHER_API_ERRORS.LOCATION_INFO_MISSING
          ? MESSAGES.LOCATION_INFO_MISSING
          : MESSAGES.FETCH_WEATHER_ERROR

      if (!config.silent) {
        showToast({
          message: toastMessage,
          duration: TOAST_DURATION.NORMAL
        })
      }

      return false
    } finally {
      if (shouldShowLoading) {
        this.isLoading = false
      }
    }
  },

  /**
   * åŠ è½½å¹¶æ˜¾ç¤ºå¤©æ°”æ•°æ®
   * @param {boolean} silent - é™é»˜æ¨¡å¼ï¼Œä¸æ˜¾ç¤ºé”™è¯¯Toast
   * @returns {Object} è¿”å› { success: boolean, status: string, weatherData?: Object }
   */
  async loadWeatherData(silent = false) {
    const result = await DataService.getTodayData(silent)

    // æ£€æŸ¥åŠ è½½çŠ¶æ€
    if (!result || result.status !== "success") {
      return {
        success: false,
        status: result?.status || "unknown",
        weatherData: null
      }
    }

    const {weatherData, todayData} = result

    // è®¡ç®—æ›´æ–°æ—¶é—´
    const updateTime = new Date(weatherData.updateTime)
    const timeAgo = DateUtils.formatTimeAgo(updateTime)

    // æ›´æ–°ç•Œé¢æ•°æ®
    WeatherDataUtils.updateCurrentWeather(this, weatherData, todayData, timeAgo)
    this.location = weatherData.location || "æœªçŸ¥åœ°ç‚¹"
    this.figure = WeatherDataUtils.getBasicWeatherFigures(todayData)
    this.dayWeather = WeatherDataUtils.processForecastData(weatherData)
    await this.loadHourlyForecastData({silent})

    return {success: true, status: "success", weatherData}
  },

  /**
   * åŒæ­¥é«˜çº§åŠŸèƒ½é…ç½®
   */
  async syncFeatureSettings(forceReload = false) {
    try {
      if (forceReload && SettingsService.clearCache) {
        SettingsService.clearCache()
      }

      if (!this.supportsAdvancedFeatures) {
        this.autoUpdateEnabled = false
        this.hourlyForecastEnabled = false
        this.hasHourlyData = false
        this.updateHourlyCardVisibility()
        return
      }

      const settings = await SettingsService.getSettings()
      this.autoUpdateEnabled = !!settings.autoUpdateEnabled
      this.hourlyForecastEnabled = !!settings.hourlyForecastEnabled
    } catch (error) {
      console.error("åŒæ­¥è®¾ç½®å¤±è´¥:", error)
    } finally {
      this.updateHourlyCardVisibility()
    }
  },

  /**
   * æ›´æ–°é€å°æ—¶å¡ç‰‡çš„å¯è§æ€§
   */
  updateHourlyCardVisibility() {
    const canShowFeature = this.supportsAdvancedFeatures && this.hourlyForecastEnabled
    const shouldShow = canShowFeature && this.hasHourlyData
    this.showHourlyForecastCard = shouldShow
    if (!shouldShow) {
      this.figureHourly = []
    }
  },

  /**
   * æ£€æµ‹è®¾å¤‡æ˜¯å¦æ”¯æŒé«˜çº§åŠŸèƒ½
   */
  async detectAdvancedFeatureSupport() {
    try {
      this.supportsAdvancedFeatures = await DeviceService.isProductSupported(ADVANCED_FEATURE_PRODUCTS)
    } catch (error) {
      console.error("æ£€æµ‹è®¾å¤‡èƒ½åŠ›å¤±è´¥:", error)
      this.supportsAdvancedFeatures = false
    } finally {
      this.updateHourlyCardVisibility()
    }
  },

  /**
   * è¯»å–æˆ–æ‹‰å–é€å°æ—¶å¤©æ°”æ•°æ®
   * @param {Object} options
   */
  async loadHourlyForecastData(options = {}) {
    if (!this.supportsAdvancedFeatures || !this.hourlyForecastEnabled) {
      this.hasHourlyData = false
      this.updateHourlyCardVisibility()
      return
    }

    const {silent = true, forceRefresh = false} = options

    if (forceRefresh) {
      HourlyDataService.clearCache()
    }

    const localData = await HourlyDataService.readHourlyData(true)

    if (localData && HourlyDataService.validateHourlyData(localData)) {
      this.applyHourlyForecastList(localData.hourly)
      return
    }

    await this.updateHourlyForecastFromApi(silent)
  },

  /**
   * é€šè¿‡ API è·å–é€å°æ—¶å¤©æ°”
   * @param {boolean} silent
   */
  async updateHourlyForecastFromApi(silent = true) {
    if (!this.supportsAdvancedFeatures || !this.hourlyForecastEnabled) {
      this.hasHourlyData = false
      this.updateHourlyCardVisibility()
      return false
    }

    try {
      const hourlyData = await WeatherApiService.fetchHourlyForecast()
      await HourlyDataService.saveHourlyData(JSON.stringify(hourlyData))
      this.applyHourlyForecastList(hourlyData.hourly)
      return true
    } catch (error) {
      console.error("è·å–é€å°æ—¶å¤©æ°”å¤±è´¥:", error)
      if (!silent) {
        const toastMessage =
          error?.code === WEATHER_API_ERRORS.LOCATION_INFO_MISSING
            ? MESSAGES.LOCATION_INFO_MISSING
            : MESSAGES.FETCH_WEATHER_ERROR

        showToast({
          message: toastMessage,
          duration: TOAST_DURATION.NORMAL
        })
      }
      this.hasHourlyData = false
      this.updateHourlyCardVisibility()
      return false
    }
  },

  /**
   * åº”ç”¨é€å°æ—¶å¤©æ°”æ•°æ®
   * @param {Array} hourlyList
   */
  applyHourlyForecastList(hourlyList = []) {
    const processed = WeatherDataUtils.processHourlyForecast(hourlyList)
    this.figureHourly = processed
    this.hasHourlyData = processed.length > 0
    this.updateHourlyCardVisibility()
  },

  /**
   * åˆ¤æ–­å¤©æ°”æ•°æ®æ˜¯å¦è¿‡æœŸ
   * @param {Object} weatherData
   * @returns {boolean}
   */
  isWeatherDataExpired(weatherData) {
    if (!weatherData || !weatherData.updateTime) {
      return false
    }

    const updatedAt = new Date(weatherData.updateTime).getTime()
    if (Number.isNaN(updatedAt)) {
      return false
    }

    return Date.now() - updatedAt >= AUTO_UPDATE.EXPIRY_THRESHOLD
  },

  /**
   * æ ¹æ®è®¾ç½®å°è¯•è‡ªåŠ¨æ›´æ–°å¤©æ°”
   * @param {Object|null} weatherData
   * @param {Object} options
   */
  async maybeAutoUpdate(weatherData, options = {}) {
    if (!this.autoUpdateEnabled || this.autoUpdateInProgress) {
      return
    }

    const {silent = true, showLoading = false} = options
    const data = weatherData || (await DataService.readWeatherData(true))

    if (!data || !this.isWeatherDataExpired(data)) {
      return
    }

    this.autoUpdateInProgress = true

    try {
      await this.UpdateWeather({
        auto: true,
        silent,
        showLoading
      })
    } finally {
      this.autoUpdateInProgress = false
    }
  },

  /**
   * é¡µé¢åˆå§‹åŒ–
   */
  async onInit() {
    // ğŸ”§ è°ƒè¯•æ¨¡å¼ï¼šæ³¨å…¥æ¨¡æ‹Ÿæ•°æ®ï¼ˆå¯é€‰ï¼‰
    // å–æ¶ˆä¸‹é¢çš„æ³¨é‡Šå¯å¯ç”¨æ¨¡æ‹Ÿæ•°æ®æ³¨å…¥
    // await DebugService.injectMockData()

    await this.detectAdvancedFeatureSupport()
    await this.syncFeatureSettings()

    // åŠ è½½æœ¬åœ°æ•°æ®ï¼ˆé™é»˜æ¨¡å¼ï¼‰
    const result = await this.loadWeatherData(true)

    // é¦–æ¬¡åŠ è½½å®Œæˆ
    if (this.isFirstLoad) {
      if (result.success) {
        // æœ‰æ•°æ®ï¼Œå…³é—­åŠ è½½åŠ¨ç”»
        this.isLoading = false
      } else {
        const shouldAutoUpdate =
          this.autoUpdateEnabled && (result.status === "expired" || result.status === "no_data")

        if (shouldAutoUpdate) {
          await this.UpdateWeather({auto: true, showLoading: true})
        } else {
          let toastMessage = MESSAGES.WAITING_FOR_FIRST_DATA

          if (result.status === "expired") {
            toastMessage = MESSAGES.WAITING_FOR_UPDATE
          } else if (result.status === "no_data") {
            toastMessage = MESSAGES.WAITING_FOR_FIRST_DATA
          }

          showToast({
            message: toastMessage,
            duration: TOAST_DURATION.LONG
          })
        }
      }
      this.isFirstLoad = false
    }

    if (result.success) {
      await this.maybeAutoUpdate(result.weatherData)
    }
  },

  /**
   * é¡µé¢æ˜¾ç¤ºæ—¶åˆå§‹åŒ–è¿æ¥å¹¶åˆ·æ–°ç¼“å­˜
   */
  async onShow() {
    await this.syncFeatureSettings()
    await this.syncFeatureSettings(true)

    // æ¸…é™¤ç¼“å­˜ï¼Œç¡®ä¿é‡æ–°ä»æœ¬åœ°æ–‡ä»¶è¯»å–
    DataService.clearCache()
    HourlyDataService.clearCache()

    // é‡æ–°åŠ è½½ä¸€æ¬¡ï¼Œä»¥ä¾¿åæ˜ å…¶ä»–é¡µé¢çš„ä¿®æ”¹
    const result = await this.loadWeatherData(true)

    if (result.success) {
      await this.maybeAutoUpdate(result.weatherData, {silent: true})
    } else if (this.autoUpdateEnabled) {
      const shouldAutoUpdate = result.status === "expired" || result.status === "no_data"
      if (shouldAutoUpdate) {
        await this.UpdateWeather({auto: true, silent: true, showLoading: false})
      }
    }

    // åˆå§‹åŒ–è¿æ¥å¹¶æ³¨å†Œæ¶ˆæ¯å¤„ç†
    ConnectionService.init((data) => {
      this.handleWeatherData(data)
    })
  },

  /**
   * å¤„ç†æ¥æ”¶åˆ°çš„å¤©æ°”æ•°æ®
   * @param {Object} data - æ¥æ”¶åˆ°çš„æ•°æ®
   */
  async handleWeatherData(data) {
    try {
      // è§£ææ•°æ®
      const weatherData = JSON.parse(data.data)

      // éªŒè¯æ•°æ®æ ¼å¼
      if (!DataService.validateWeatherData(weatherData)) {
        showToast({
          message: MESSAGES.DATA_FORMAT_ERROR,
          duration: TOAST_DURATION.NORMAL
        })
        this.isLoading = false
        return
      }

      // è®¡ç®—æ›´æ–°æ—¶é—´
      const updateTime = new Date(weatherData.updateTime)
      const timeAgo = DateUtils.formatTimeAgo(updateTime)
      const todayStr = DateUtils.getTodayString()

      // æŸ¥æ‰¾ä»Šå¤©çš„æ•°æ®
      const todayData = weatherData.daily.find((day) => day.fxDate === todayStr)

      if (!todayData) {
        showToast({
          message: MESSAGES.DATA_MISSING,
          duration: TOAST_DURATION.NORMAL
        })
        return
      }

      // æ›´æ–°ç•Œé¢
      WeatherDataUtils.updateCurrentWeather(this, weatherData, todayData, timeAgo)
      this.location = weatherData.location || "æœªçŸ¥åœ°ç‚¹"
      this.figure = WeatherDataUtils.getBasicWeatherFigures(todayData)
      this.dayWeather = WeatherDataUtils.processForecastData(weatherData)

      // ä¿å­˜æ•°æ®åˆ°æœ¬åœ°
      await DataService.saveWeatherData(data.data)

      showToast({
        message: MESSAGES.DATA_UPDATED,
        duration: TOAST_DURATION.SHORT
      })
    } catch (e) {
      showToast({
        message: MESSAGES.DATA_PARSE_ERROR,
        duration: TOAST_DURATION.NORMAL
      })
      console.error("æ•°æ®è§£æå¤±è´¥:", e)
    } finally {
      this.isLoading = false
      ConnectionService.resetConnectionState()
    }
  },

  /**
   * é¡µé¢éšè—æ—¶å…³é—­è¿æ¥
   */
  onHide() {
    ConnectionService.close()
  },

  /**
   * é¡µé¢é”€æ¯æ—¶å…³é—­è¿æ¥
   */
  onDestroy() {
    ConnectionService.close()
  }
}
</script>

<style>
/* å¼•å…¥å…¬å…±æ ·å¼ */
@import "../../common/css/style.css";
@import "../../common/css/loading-styles.css";
@import "../../common/css/page-bg-styles.css";
</style>
